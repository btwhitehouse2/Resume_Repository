Final Project Readme

This Readme will cover everything that I have done for the REGIE Final Project
Database Design:
I have implemented a 3 table schema using SQL and bldTables.py. The goal is to ensure that I have 
tables that are clean and running.

Tables:
user = a table that tracks all users: students, faculty and admin.
course = a table that tracks all course to include userid for the faculty member who is teaching this course 
(instantiate this table after user).
log = a lookup table that tracks all registrations attempts made by a student.
'log' has a field called action which is important to ensure that a student
is either 'registered', 'denied' from a resricted course or 'waiting' for a resricted
course. log table also tracks courseid and userid for the student.
(The unique primary keys of userid and courseid are referenced in the look up table, 'log')

Code:
The main begins with the initiation for factory classes to build data and objects.
The three objects a fulltime student, fulltime faculty and administrator exist in both
the database and as a objects.
The main is also where the 3 scenarios:
1) Registration for a Restricted Class
2) Registering for a Class that is Full
3) Faculty requests creation of a new course from Admin
This is done using print lines and a snippet of the terminal response has been provided.

The test_interface tests the interface classes to ensure that the database queries
are working as intended. 

Finally I save all of the data log to a MongoDB NOSQL databse

OOP Design:
The following are Object Oriented Design Patterns that I used in the creation of this project
1)Facade pattern was used when designing an interface for each user class and the classes that
inherit from user. This structural pattern limits the options available, but allows for 
a cleaning more user friendly code base. In this way a user is not able to query the total 
number of users in the database that are register for exactly 2 classes. However, this is not
a normal request and could be added later if they were a reason to. 
2)Chain of Responsibility, desing pattern recieve request and pass to next handler in the chain
Proxy pattern. 
3)Decorator were used in my user classes by labeling user as an ABC or abstrac base class that 
clearly denotes and will not allow user to be instantiated as an object and instead can
only be inherited from.
4)By breaking all of the interfaces into interface classes I have followed interface segregation
this means that a user cannot directly talk a database or to a database interface, but instead
must talk to the user interface.
5 & 6)I used the Builder design pattern to generate users for my table, each one of these classes 
contains a single responsibility per class as well following the sinlge responsibility design pattern
from SOLID.
7)I follow the open closed principle by creating a base class user and then having all of the
different types of user inherit from this. In the future if I wanted to create an account for
alumni, I would not have to modify that base class merely inherit from user. 
8)In addition, my users follow Liskov Substitution Principle by never inheritting anything that
the class does not need. Such as faculty and administrators do not need to register for classes
therefore this function only exists in user.
9)Dependency Inversion is followed throughout my interfaces as I ask the user for minimal 
information and leverage my ability to query the majority of that information from already 
existing data in tables. Ie. I only ask for userid and courseid not fullname, email, coursename 
etc. because this places and undue burden on the user and can be looked up by the program 
itself.


